### Plots heatmaps with the quaility of the fit between the analytical model predictions and the ChIP-seq profiles
### occupancy: a list (lambda) of lists (bound molecules) of the dataset generated by computeOccupancy method
### TF: the array of the names of TFs for which the heatmaps will be generated.
### lambdas:an array with all used values of lambda when computing the occupancy lists.
### boundMolecules: an array with all used values of number of bound molecules when computing the occupancy lists.
### directory="": the directory were the file will be saved
### plotFilename="": the filename of the graph to be ploted
### imageType="pdf" a string that specifies the image type. Can be: eps or pdf
### contour=FALSE: a logical value indicating whether the contour should be drawn over the heatmap
plotOccupancyModelQualityHeatmaps <-function(occupancy, TF, lambdas, boundMolecules, directory="", plotFilename="", imageType="pdf", contour=FALSE){
	
	figLabels = c("A", "B", "C", "D", "E", "F","G","H", "I","J","K","L","M","N");
	
	
	path="";
	if(!is.null(directory) & nchar(directory) > 0){
		path=paste(directory,"/", sep="");
	}
	
	contourColor="darkolivegreen3";
	heatColors=rev(heat.colors(100));

	xlabs=boundMolecules;
	ylabs=lambdas;
	
	filename=paste("occupancyModelQualityHeatmap",plotFilename,".",sep="");
	


	if(length(TF)>1){
		if(imageType=="pdf"){
			pdf(paste(path,filename,imageType,sep=""), width=(4.5*length(TF)), height=(3*3.5),pointsize = 10);
		} else if(imageType=="eps"){
			postscript(paste(path,filename,imageType,sep=""), width=(4.5*length(TF)), height=(3*5.5),pointsize = 10);
		}
		par(mfrow=c(3,length(TF)));
		
		if(length(TF)>4){
			par(cex=0.6);
		} else{
			par(cex=0.6);
		}
		
	} else{
		if(imageType=="pdf"){
			pdf(paste(path,filename,imageType,sep=""), width=4.5, height=(3*3.5),pointsize = 10);
		} else if(imageType=="eps"){
			postscript(paste(path,filename,imageType,sep=""), width=4.5, height=(3*5.5),pointsize = 10);
		}
		par(mfrow=c(3,1));
		par(cex=0.6);
	}
	
	par(mar=c(4, 4, 4, 1)+0.1);
	

	#plot heatmaps for the correlation
	for(TFid in 1:length(TF)){
		
		
		meanCorrelation=matrix(0,nrow=length(lambdas),ncol=length(boundMolecules));
		for(j in 1:length(lambdas)){
			for(k in 1:length(boundMolecules)){
				meanCorrelation[j,k] = occupancy[[j]][[k]]$meanCorrelation[[TF[TFid]]];
			}
		}

		image(1:length(xlabs),1:length(ylabs),t(meanCorrelation), axes = FALSE, main="", xlab="number of bound molecules", ylab=expression(lambda), zlim=c(0,1),col=heatColors);
		title(main=bquote(rho[.(TF[TFid])]), cex.main = 2.0);

		for(textXId in 1:length(xlabs)){
			for(textYId in 1:length(ylabs)){
				text(textXId,textYId,signif(meanCorrelation[textYId,textXId],3),cex=0.7);
			}	
		}
		if(contour){
			contour(1:length(xlabs),1:length(ylabs), t(meanCorrelation), levels = seq(0, 1, by = 0.05), add = TRUE, col = contourColor, lwd=2, labcex = 1.0)
		}
		axis(BELOW<-1, at=1:length(xlabs), labels=xlabs, cex.axis=0.7)
		axis(LEFT <-2, at=1:length(ylabs), labels=ylabs, las= HORIZONTAL<-1,cex.axis=0.7)
		mtext(figLabels[(TFid)], line = 0.5, adj =0, cex=2.0);  
		
	}

	#plot heatmaps for mean square error
	for(TFid in 1:length(TF)){
		meanMSE=matrix(0,nrow=length(lambdas),ncol=length(boundMolecules));
		for(j in 1:length(lambdas)){
			for(k in 1:length(boundMolecules)){
				meanMSE[j,k] = occupancy[[j]][[k]]$meanMSE[[TF[TFid]]];
			}
		}
		
		image(1:length(xlabs),1:length(ylabs),t(log10(meanMSE)), axes = FALSE, main = "", xlab="number of bound molecules", ylab=expression(lambda),col=heatColors)
		title(main=bquote(MSE[.(TF[TFid])]), cex.main = 2.0);

		for(textXId in 1:length(xlabs)){
			for(textYId in 1:length(ylabs)){
				text(textXId,textYId,format(((meanMSE))[textYId,textXId],digits=2,scientific=TRUE),cex=0.7)
			}	
		}
		if(contour){
			contour(1:length(xlabs),1:length(ylabs), t(log10(meanMSE*1000)), add = TRUE, col = contourColor, lwd=2, labcex = 1.0)
		}
		axis(BELOW<-1, at=1:length(xlabs), labels=xlabs, cex.axis=0.7)
		axis(LEFT <-2, at=1:length(ylabs), labels=ylabs, las= HORIZONTAL<-1,cex.axis=0.7)
		mtext(figLabels[(TFid)+length(TF)], line = 0.5, adj =0, cex=2.0);  
		
	}
	
	#plot heatmaps for mean square error
	for(TFid in 1:length(TF)){
		
		meanTheta=matrix(0,nrow=length(lambdas),ncol=length(boundMolecules));
		for(j in 1:length(lambdas)){
			for(k in 1:length(boundMolecules)){
				meanTheta[j,k] = occupancy[[j]][[k]]$meanTheta[[TF[TFid]]];
			}
		}
		
		
		image(1:length(xlabs),1:length(ylabs),t(meanTheta), axes = FALSE, main="", xlab="number of bound molecules", ylab=expression(lambda),col=heatColors);
		title(main=bquote(theta[.(TF[TFid])]), cex.main = 2.0);
		
		for(textXId in 1:length(xlabs)){
			for(textYId in 1:length(ylabs)){
				text(textXId,textYId,format(meanTheta[textYId,textXId],digits=2,scientific=TRUE),cex=0.7);
			}	
		}
		if(contour){
			contour(1:length(xlabs),1:length(ylabs), t(meanTheta), add = TRUE, col = contourColor, lwd=2, labcex = 1.0)
		}
		axis(BELOW<-1, at=1:length(xlabs), labels=xlabs, cex.axis=0.7)
		axis(LEFT <-2, at=1:length(ylabs), labels=ylabs, las= HORIZONTAL<-1,cex.axis=0.7)
		mtext(figLabels[(TFid)+2*length(TF)], line = 0.5, adj =0, cex=2.0);  
	}
	
	dev.off();
	
	
}


### Plots box plots with the quaility of the fit between the analytical model predictions and the ChIP-seq profiles. It also creates a csv file with the number of loci included for each TF and threshold
### occupancy: a list (lambda) of lists (bound molecules) of the dataset generated by computeOccupancy method
### TF: the array of the names of TFs for which the heatmaps will be generated.
### directory="": the directory were the file will be saved
### plotFilename="": the filename of the graph to be ploted
### imageType="pdf": a string that specifies the image type. Can be: eps or pdf
### threshold: a vector with the thresholds (the mean ChIP-seq signal at a loci needs to be higher than threshold*backgroundSignal)
### backgroundSignal: a list with all background levels of ChIP-seq profiles
### profile: a list with ChIP-seq signal at all loci
### thresholdOnlyChIP=TRUE: this is TRUE if the regions are selected only based on the ChIP-seq average signal. If FALSE, it also selects the regions with a predicted signal higher than the threshold
### return a matrix consisting of the number of DNA segments that display a ChIP-seq signal higher than the threshold (columns represent each TF and rows each threshold)
plotStatistics <- function(occupancy, TF, directory="", plotFilename="", imageType="pdf", threshold, backgroundSignal, profile, thresholdOnlyChIP=TRUE){
	
	figLabels = c("A", "B", "C", "D", "E", "F","G","H", "I","J","K","L","M","N");
	
	
	path="";
	if(!is.null(directory) & nchar(directory) > 0){
		path=paste(directory,"/", sep="");
	}
	
	filename=paste("OccupancyStatisticsBoxplot",plotFilename,".",sep="");
	
	

	locationsWithSignal=vector("list", length(threshold));
	correlationLocal=vector("list", length(threshold));
	mseLocal=vector("list", length(threshold));
	thetaLocal=vector("list", length(threshold));
		
	regions=matrix(0,nrow= length(threshold), ncol=length(TF))
	colnames(regions)=TF
	rownames(regions)=threshold
    
	for(i in 1:length(threshold)){	
	       
		# extract the locations with signal higher than a threshold
		locationsWithSignal[[i]]=vector("list", length(TF));
		for(j in 1:length(TF)){
			buffer=c();
			for(k in 1:length(profile[[j]])){
				meanSignalLocal=mean(profile[[j]][[k]]);
				meanEstimateLocal=mean(occupancy$occupancyAbundanceChIP[[j]][[k]]);
				if((!is.na(meanSignalLocal) & meanSignalLocal > threshold[i]*backgroundSignal[[j]]) |
				   (!thresholdOnlyChIP & (!is.na(meanEstimateLocal) & meanEstimateLocal > threshold[i]*backgroundSignal[[j]]))){
					buffer=c(buffer,k); 
				}
			}
			locationsWithSignal[[i]][[j]]=buffer;
		}

		regions[i,]=unlist(lapply(locationsWithSignal[[i]],length));
		#print(unlist(lapply(locationsWithSignal[[i]],length)));
		correlationLocal[[i]]=vector("list", length(TF));
		names(correlationLocal[[i]])=TF;
		mseLocal[[i]]=vector("list", length(TF));
		names(mseLocal[[i]])=TF;
		thetaLocal[[i]]=vector("list", length(TF));
		names(thetaLocal[[i]])=TF;
		
		for(j in 1:length(TF)){
			bufferCorrelation=c();
			bufferMSE=c();
			bufferTheta=c();
			for(k in locationsWithSignal[[i]][[j]]){
				bufferCorrelation=c(bufferCorrelation,occupancy$correlation[[j]][k]);
				bufferMSE=c(bufferMSE,occupancy$MSE[[j]][k]*1000);
				bufferTheta=c(bufferTheta,occupancy$correlation[[j]][k]/(occupancy$MSE[[j]][k]*1000));
			}	
			correlationLocal[[i]][[j]]=bufferCorrelation;
			mseLocal[[i]][[j]]=bufferMSE;
			thetaLocal[[i]][[j]]=bufferTheta;
            
		}
	}

   
	#plot the boxplots with the statistics
	if(imageType=="pdf"){
		pdf(paste(path,filename,imageType,sep=""), width=(9), height=(3*length(threshold)),pointsize = 10);
	} else if(imageType=="eps"){
		postscript(paste(path,filename,imageType,sep=""), width=(9), height=(3*length(threshold)),pointsize = 10);
	}
	par(mfrow=c(length(threshold),3));
	
	par(cex=0.9);

	for(i in 1:length(threshold)){
		boxplot(correlationLocal[[i]], main="", ylab="")
		title(main=bquote(rho[.(threshold[i])]));
		mtext(figLabels[(i-1)*3+1], line = 0.5, adj =0, cex=1.6);  
		boxplot(mseLocal[[i]], main="", ylab="",log="y")
		title(main=bquote(MSE[.(threshold[i])]));
		mtext(figLabels[(i-1)*3+2], line = 0.5, adj =0, cex=1.6);  
		boxplot(thetaLocal[[i]], main="", ylab="")
		title(main=bquote(theta[.(threshold[i])]));
		mtext(figLabels[(i-1)*3+3], line = 0.5, adj =0, cex=1.6);
	}
	dev.off();
	return(regions);
}







### Plots occupancy profile.
### The grey shade represents the ChIP-seq signal, the red line the predicted profile from the model, the orange shade the inaccessible DNA and the vertical green lines the exponential of the PWM score
### occupancy: a list consisting of the computed profile at each loci
### PWMScore: a list consisting of the PWM scores at each loci
### lambda: the scaling factor of the PWM score
### maxPWMScore: the genome wide maximum PWM score
### DNAAccessibility=NULL: a list contsisting of the DNA accessibility data at each loci
### directory="": the folder where to save the plot
### plotFilename="": the plot filename (an extension and a prefix will be added to the plot filename)
### profile=NULL: a list consisting of the ChIP-seq signal at eac loci
### imageType="pdf" a string that specifies the image type. It can be eps or pdf.
### setSequence=NULL: the genomic ranges where to plot the profile. if NULL, nothing is plotted. 
### TF=NULL: the TF name for each the profile is plotted
### boundMolecules=NULL: the number of bound molecules 
### outputPWMScore=TRUE: logical value indicating whether the method should output the PWM score or not.
### outputOccupancyAbundance=TRUE: logical value indicating whether the method should output the  profile computed based on PWM score and number of bound molecules.
### geneRef=NULL. The gene reference list to be added to the graph. If NULL nothing is added. 
### stepSize=NULL. An integer indicating the step size of the landscape. 
plotOccupancyProfile <-function(occupancy, PWMScore, lambda, maxPWMScore, DNAAccessibility=NULL, directory="", plotFilename="", profile=NULL, imageType="pdf", setSequence=NULL,TF="", boundMolecules=NULL, outputPWMScore=TRUE, outputOccupancyAbundance=TRUE, geneRef=NULL,stepSize=NULL){
	
	# colors
	colAccessibility=rgb(255,228,196,255,maxColorValue=255);
	colPWM=rgb(110,139,61,255,maxColorValue=255);
	colChIP=rgb(131,139,139,255,maxColorValue=255);
	colModel=rgb(139,62,47,255,maxColorValue=255);
	
	if(!is.null(setSequence)){
		
		#se the path to the destination directory
		path="";
		if(!is.null(directory) & nchar(directory) > 0){
			path=paste(directory,"/", sep="");
		}
	

	
		for(gr in 1:length(setSequence)){
			

			#get the id of the location in the list of loci
			chr=as.vector(seqnames(setSequence))[gr];
			range=ranges(setSequence);
			startPositon = as.vector(range@start)[gr];
			endPosition = as.vector(end(range))[gr];
			
			#the occupancy is computed just at the recorded sequences
			grID = which(names(PWMScore) == names(setSequence)[gr]);
			if(length(grID)!=1){
				grID=NULL;
			}
			
		
			if(is.null(grID)){
				print(paste("could not locate loci ",chr,":",startPositon,"..",endPosition, sep=""));
			} else{
			
				# the occupancy is computed genome wide and needs to be extracted at certain loci
	
				positions=startPositon:endPosition; 
					
				#generate the list of genese		
				geneList=NULL;
				enhancerList=NULL;
				if(!is.null(geneRef)) {
					if(length(which(names(geneRef)=="exon"))>0){
						ids = intersect(intersect(which(start(ranges(geneRef$exon))<endPosition), which(end(ranges(geneRef$exon))>=startPositon)), which(as.vector(seqnames(geneRef$exon))==chr));	
						geneList = list("location"=geneRef$exon[ids],"name"=names(geneRef$exon[ids]));
					}
					if(length(which(names(geneRef)=="enhancer"))>0){
						ids = intersect(intersect(which(start(ranges(geneRef$enhancer))<endPosition), which(end(ranges(geneRef$enhancer))>=startPositon)), which(as.vector(seqnames(geneRef$enhancer))==chr));	
						enhancerList = list("location"=geneRef$enhancer[ids],"name"=names(geneRef$enhancer[ids]));
					}
				}					 
									 
			

			
			
			
				filename=paste("OccupancyProfileAt",names(setSequence)[gr],"BoundMolecules",boundMolecules,plotFilename,".",sep="");
				if(imageType=="pdf"){
					pdf(paste(path,filename,imageType,sep=""), width=9, height=(2.25),pointsize = 10);
					
				} else if(imageType=="eps"){
					postscript(paste(path,filename,imageType,sep=""), width=9, height=(2.25),pointsize = 10);
	
				}
				par(mfrow=c(1,1));
				par(mar=c(4, 4, 3, 1)+0.1);
				par(cex=0.8);
				
				accesibilityNorm=DNAAccessibility[[grID]];
				
				if(outputOccupancyAbundance & !is.null(occupancy)){

					modelProfile=occupancy[[grID]];
					
					ylimMin = 0; 
					if(!is.null(geneList)){
						ylimMin= -0.5;
					}
					
					plotTitle="PWM and TF abundance";
					if(!is.null(TF) & !is.null(names(setSequence))){
						plotTitle=paste(TF," (",boundMolecules," molecules) @ ",names(setSequence)[gr], " locus", sep="");
					}
										
					localPositions=positions;
					localAccesibilityNorm=accesibilityNorm;
					localProfile=profile[[grID]];
					localModelProfile=modelProfile;
					if(!is.null(stepSize)){
						stepSize=round(stepSize);
						if(stepSize>1){
							localIndexes=seq(from=1,to=length(localPositions),by=stepSize);
							localPositions=rep(0,times=(length(localIndexes)-1));
							localAccesibilityNorm=rep(0,times=(length(localIndexes)-1));
							localProfile=rep(0,times=(length(localIndexes)-1));
							localModelProfile=rep(0,times=(length(localIndexes)-1));
							for(i in 1:(length(localIndexes)-1)){
								localPositions[i]=mean(positions[localIndexes[i]:(localIndexes[i+1]-1)]);
								localAccesibilityNorm[i]=mean(accesibilityNorm[localIndexes[i]:(localIndexes[i+1]-1)]);
								localProfile[i]=mean(profile[[grID]][localIndexes[i]:(localIndexes[i+1]-1)]);
								localModelProfile[i]=mean(modelProfile[localIndexes[i]:(localIndexes[i+1]-1)]);
							}
						}
					}
					
					localPositions=c(positions[1]-1,localPositions,positions[length(positions)]+1);
					localAccesibilityNorm=c(0,(1-localAccesibilityNorm),0);
					localProfile=c(0,localProfile, 0);
					localModelProfile=c(0,localModelProfile, 0);

					plot(localPositions, localModelProfile, type="n", yaxt="n", main=plotTitle, col=colModel, lty=1, lwd=2, pch=1, xlab="DNA position", ylab="occupancy", xlim=range(positions), ylim=c(ylimMin,1.5));

					
					if(!is.null(accesibilityNorm)){
						polygon(localPositions, localAccesibilityNorm, col=colAccessibility, border=NA) 
					}
					
					if(!is.null(profile)){
						polygon(localPositions,localProfile, col=colChIP, border=NA) 
					}		
				
					if(outputPWMScore){					
						PWMScoreNorm=PWMScore[[grID]];
						PWMScoreNorm = (exp((1/lambda)*PWMScoreNorm))/(exp((1/lambda)*maxPWMScore));
						indexesAll=which(PWMScoreNorm>0.01);
						lines(positions[indexesAll], PWMScoreNorm[indexesAll], type="h", col=colPWM, lty=1, lwd=1.0, pch=1);
					}
				
					if(!is.null(profile[[grID]])){
						statTxt = paste("correlation = ",signif(cor(profile[[grID]],modelProfile),2), sep="");	
						statTxt = paste(statTxt, "; MSE = ",signif(1000*sum((profile[[grID]]-modelProfile)^2) / length(profile[[grID]]),3), sep="");
						statTxt=bquote(rho[.(TF)] ~ " = " ~ .(signif(cor(profile[[grID]],modelProfile),2)) ~ "; "~ MSE[.(TF)] ~ " = " ~ .(signif(1000*sum((profile[[grID]]-modelProfile)^2) / length(profile[[grID]]),3)));
	
						mtext(statTxt, line = -1.5, adj =0.99, cex=1.0); 
						mtext(chr, line = -1.5, adj =0.01, cex=1.0);  
					}
					
					lines(localPositions, localModelProfile, pch=1, col=colModel, lty=1, lwd=2);
	
					if(!is.null(geneList)){
						
						for(geneName in unique(geneList$name)){
							lastExonXend = -1;
							lastExonYmed = -1;
							firstExonXStart = -1;
							
							for(k in which(geneList$name==geneName)){
								exonXStart = start(ranges(geneList$location[k]));
								exonXEnd = end(ranges(geneList$location[k]));
								exonYStart=-0.39;
								if(as.vector(strand(geneList$location[k])) == "+"){
									exonYStart = -0.25; 
								}
								exonYEnd=exonYStart+0.10;
								
								rect(exonXStart, exonYStart, exonXEnd, exonYEnd, col = "cadetblue4", border = "cadetblue4",lwd = 0);
								if(lastExonXend >= 0){
									lines(c(lastExonXend,exonXStart),c(lastExonYmed,((exonYStart + exonYEnd)/2)), col = "cadetblue4",lty=1, lwd=1);
								} else{
									firstExonXStart=exonXStart;
								}
								lastExonXend = exonXEnd;
								lastExonYmed = (exonYStart + exonYEnd)/2;
							}
							
							textPos=-0.465;
							if(exonYStart == -0.25){
								textPos=-0.085;		
							}
							
							text(((firstExonXStart+lastExonXend)/2), (textPos), geneName, cex = .6, col="black");
							
						}
						lines(c(min(positions),max(positions)),c(-0.26,-0.26), col = "black",lty=1, lwd=0.5);
						text(min(positions), -0.10, "+", cex = .6, col="black");
						text(min(positions), -0.42, "-", cex = .6, col="black");
						
						
					}
					
					if(!is.null(enhancerList)){
						
						for(enhancerName in unique(enhancerList$name)){
							lastEnhancerXend = -1;
							lastEnhancerYmed = -1;
							firstEnhancerXStart = -1;
							
							for(k in which(enhancerList$name==enhancerName)){
								enhancerXStart = start(ranges(enhancerList$location[k]));
								enhancerXEnd = end(ranges(enhancerList$location[k]));
								enhancerYStart=-0.39;
								enhancerYEnd=enhancerYStart+0.10;
								
								rect(enhancerXStart, enhancerYStart, enhancerXEnd, enhancerYEnd, col = "darkorchid3", border = "darkorchid3",lwd = 0);
								if(lastEnhancerXend >= 0){
									lines(c(lastEnhancerXend,enhancerXStart),c(lastEnhancerYmed,((enhancerYStart + enhancerYEnd)/2)), col = "darkorchid3",lty=1, lwd=1);
								} else{
									firstEnhancerXStart=enhancerXStart;
								}
								lastEnhancerXend = enhancerXEnd;
								lastEnhancerYmed = (enhancerYStart + enhancerYEnd)/2;
							}
							
							textPos=-0.465;
							if(enhancerYStart == -0.25){
								textPos=-0.085;		
							}
							
							text(((firstEnhancerXStart+lastEnhancerXend)/2), (textPos), enhancerName, cex = .6, col="black");
							
						}
						if(is.null(geneList)){
							lines(c(min(positions),max(positions)),c(-0.26,-0.26), col = "black",lty=1, lwd=0.5);
							text(min(positions), -0.10, "+", cex = .6, col="black");
							text(min(positions), -0.42, "-", cex = .6, col="black");
						}
						
						
					}
					
	
				}
				
				
			}
						
			dev.off();
		}
		
	}		
	
	
}
