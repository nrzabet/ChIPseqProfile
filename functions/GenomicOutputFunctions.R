### Plots heatmaps with the quaility of the fit between the analytical model predictions and the ChIP-seq profiles
### occupancy: a list (lambda) of lists (bound molecules) of the dataset generated by computeOccupancy method
### TF: the array of the names of TFs for which the heatmaps will be generated.
### lambdas:an array with all used values of lambda when computing the occupancy lists.
### boundMolecules: an array with all used values of number of bound molecules when computing the occupancy lists.
### directory="": the directory were the file will be saved
### plotFilename="": the filename of the graph to be ploted
### imageType="pdf" a string that specifies the image type. Can be: eps or pdf
### contour=FALSE: a logical value indicating whether the contour should be drawn over the heatmap
plotOccupancyModelQualityHeatmaps <-function(occupancy, TF, lambdas, boundMolecules, directory="", plotFilename="", imageType="pdf", contour=FALSE, regionsThreshold=0.1){
	
	figLabels = c("A", "B", "C", "D", "E", "F","G","H", "I","J","K","L","M","N","O");
	
    cbbPalette = c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7");
	cbPalette = c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7");
    
	path="";
	if(!is.null(directory) & nchar(directory) > 0){
		path=paste(directory,"/", sep="");
	}
	
	contourColor="bisque2";

	heatColors=rev(heat.colors(100));

	xlabs=boundMolecules;
	ylabs=lambdas;

	selectedColor="gray20";
	optimumColor="darkolivegreen3";
	



    
	filename=paste("occupancyModelQualityHeatmap",plotFilename,".",sep="");
	
    corrColor=cbbPalette[5];
    mseColor=cbbPalette[3];
    intersectionColor=cbbPalette[4];
    selectedColor=cbbPalette[1];
	optimumColor=cbPalette[7];
    contourColor=cbPalette[2];
    
    corrColor=cbbPalette[7];
    mseColor=cbbPalette[6];
    intersectionColor=cbbPalette[8];
    selectedColor=cbbPalette[1];
	optimumColor=cbPalette[4];
    contourColor=cbPalette[5];

	colfunc=colorRampPalette(c("white", corrColor));
	correlationColors=colfunc(100);
	colfunc=colorRampPalette(c(mseColor,"white"));
	MSEColors=colfunc(100);
	colfunc=colorRampPalette(c(corrColor,mseColor));
	bufferCols=colfunc(20);
	regionsColors=c("white",corrColor,mseColor,intersectionColor);

	if(length(TF)>1){
		if(imageType=="pdf"){
			pdf(paste(path,filename,imageType,sep=""), width=(4.5*length(TF)), height=(3*3.5),pointsize = 10);
		} else if(imageType=="eps"){
			postscript(paste(path,filename,imageType,sep=""), width=(4.5*length(TF)), height=(3*5.5),pointsize = 10);
		}
		par(mfrow=c(3,length(TF)));
		
		if(length(TF)>4){
			par(cex=0.6);
		} else{
			par(cex=0.6);
		}
		
	} else{
		if(imageType=="pdf"){
			pdf(paste(path,filename,imageType,sep=""), width=4.5, height=(3*3.5),pointsize = 10);
		} else if(imageType=="eps"){
			postscript(paste(path,filename,imageType,sep=""), width=4.5, height=(3*5.5),pointsize = 10);
		}
		par(mfrow=c(3,1));
		par(cex=0.6);
	}
	
	par(mar=c(4, 4, 4, 1)+0.1);
	

	#plot heatmaps for the correlation
	for(TFid in 1:length(TF)){
		
		
		meanCorrelation=matrix(0,nrow=length(lambdas),ncol=length(boundMolecules));
		for(j in 1:length(lambdas)){
			for(k in 1:length(boundMolecules)){
				meanCorrelation[j,k] = occupancy[[j]][[k]]$meanCorrelation[[TF[TFid]]];
			}
		}

		image(1:length(xlabs),1:length(ylabs),t(meanCorrelation), axes = FALSE, main="", xlab="number of bound molecules", ylab=expression(lambda),col=correlationColors);
		#title(main=bquote(rho[.(TF[TFid])]), cex.main = 2.0);
		title(main=paste("correlation (",TF[TFid],")",sep=""), cex.main = 1.6);

		for(textXId in 1:length(xlabs)){
			for(textYId in 1:length(ylabs)){
				text(textXId,textYId,signif(meanCorrelation[textYId,textXId],3),cex=0.7);
			}	
		}
		if(contour){
			contour(1:length(xlabs),1:length(ylabs), t(meanCorrelation), levels = seq(0, 1, by = 0.05), add = TRUE, col = contourColor, lwd=1, labcex = 1.0)
		}
		axis(BELOW<-1, at=1:length(xlabs), labels=xlabs, cex.axis=0.7)
		axis(LEFT <-2, at=1:length(ylabs), labels=ylabs, las= HORIZONTAL<-1,cex.axis=0.7)
		mtext(figLabels[(TFid)], line = 0.7, adj =0, cex=1.6);  
		
	}

	#plot heatmaps for mean square error
	for(TFid in 1:length(TF)){
		meanMSE=matrix(0,nrow=length(lambdas),ncol=length(boundMolecules));
		for(j in 1:length(lambdas)){
			for(k in 1:length(boundMolecules)){
				meanMSE[j,k] = occupancy[[j]][[k]]$meanMSE[[TF[TFid]]];
			}
		}
		
		image(1:length(xlabs),1:length(ylabs),t(log10(meanMSE)), axes = FALSE, main = "", xlab="number of bound molecules", ylab=expression(lambda),col=MSEColors)
		#title(main=bquote(MSE[.(TF[TFid])]), cex.main = 2.0);
		title(main=paste("mean squared error (",TF[TFid],")",sep=""), cex.main = 1.6);

		for(textXId in 1:length(xlabs)){
			for(textYId in 1:length(ylabs)){
				text(textXId,textYId,format(((meanMSE))[textYId,textXId],digits=2,scientific=TRUE),cex=0.7)
			}	
		}
		if(contour){
			contour(1:length(xlabs),1:length(ylabs), t(log10(meanMSE*1000)), add = TRUE, col = contourColor, lwd=1, labcex = 1.0)
		}
		axis(BELOW<-1, at=1:length(xlabs), labels=xlabs, cex.axis=0.7)
		axis(LEFT <-2, at=1:length(ylabs), labels=ylabs, las= HORIZONTAL<-1,cex.axis=0.7)
		mtext(figLabels[(TFid)+length(TF)], line = 0.7, adj =0, cex=1.6);  
	}
	
	#plot heatmaps for mean square error
	for(TFid in 1:length(TF)){
		
		meanCorrelation=matrix(0,nrow=length(lambdas),ncol=length(boundMolecules));
		for(j in 1:length(lambdas)){
			for(k in 1:length(boundMolecules)){
				meanCorrelation[j,k] = occupancy[[j]][[k]]$meanCorrelation[[TF[TFid]]];
			}
		}

		meanMSE=matrix(0,nrow=length(lambdas),ncol=length(boundMolecules));
		for(j in 1:length(lambdas)){
			for(k in 1:length(boundMolecules)){
				meanMSE[j,k] = occupancy[[j]][[k]]$meanMSE[[TF[TFid]]];
			}
		}
		
		buffer=log10(as.vector(meanMSE));
		thresholdMSE=10^(min(buffer)+regionsThreshold*(max(buffer)-min(buffer)))
		buffer=(as.vector(meanCorrelation));
		thresholdCorrelation=(min(buffer)+(1-regionsThreshold)*(max(buffer)-min(buffer)))


		meanTheta=matrix(0,nrow=length(lambdas),ncol=length(boundMolecules));
    
		for(j in 1:length(lambdas)){
			for(k in 1:length(boundMolecules)){
				if(!is.na(meanCorrelation) & meanCorrelation[j,k]>=thresholdCorrelation){	
					meanTheta[j,k] = meanTheta[j,k] + 1;
				}
				if(!is.na(meanMSE) & meanMSE[j,k]<=thresholdMSE){	
					meanTheta[j,k] = meanTheta[j,k] + 2;
				}

			}
		}



		#regionsColors=c("white","coral4","cadetblue4","darkorchid4");
		#regionsColors=c("white",rev(heat.colors(3)));
		image(1:length(xlabs),1:length(ylabs),t(meanTheta), axes = FALSE, main="", xlab="number of bound molecules", ylab=expression(lambda),col=regionsColors);
		#title(main=bquote(theta[.(TF[TFid])]), cex.main = 2.0);
		title(main=paste("optimal parameters (",TF[TFid],")",sep=""), cex.main = 1.6);

		rectanglePoints=which(meanTheta==3, arr.ind = TRUE);
	
		rect(min(rectanglePoints[,2])-0.5,min(rectanglePoints[,1])-0.5,max(rectanglePoints[,2])+0.5,max(rectanglePoints[,1])+0.5, border=selectedColor, lwd=2);
		rectanglePoints=which(meanMSE==min(meanMSE), arr.ind = TRUE);
		rect(rectanglePoints[,2]-0.5,rectanglePoints[,1]-0.5,rectanglePoints[,2]+0.5,rectanglePoints[,1]+0.5, border=optimumColor, lwd=2);
		
		axis(BELOW<-1, at=1:length(xlabs), labels=xlabs, cex.axis=0.7)
		axis(LEFT <-2, at=1:length(ylabs), labels=ylabs, las= HORIZONTAL<-1,cex.axis=0.7)
		mtext(figLabels[(TFid)+2*length(TF)], line = 0.7, adj =0, cex=1.6);  
	}
	
	dev.off();
	
	
}


### Plots box plots with the quaility of the fit between the analytical model predictions and the ChIP-seq profiles. It also creates a csv file with the number of loci included for each TF and threshold
### occupancy: a list (lambda) of lists (bound molecules) of the dataset generated by computeOccupancy method
### TF: the array of the names of TFs for which the heatmaps will be generated.
### directory="": the directory were the file will be saved
### plotFilename="": the filename of the graph to be ploted
### imageType="pdf": a string that specifies the image type. Can be: eps or pdf
### threshold: a vector with the thresholds (the mean ChIP-seq signal at a loci needs to be higher than threshold*backgroundSignal)
### backgroundSignal: a list with all background levels of ChIP-seq profiles
### profile: a list with ChIP-seq signal at all loci
### thresholdOnlyChIP=TRUE: this is TRUE if the regions are selected only based on the ChIP-seq average signal. If FALSE, it also selects the regions with a predicted signal higher than the threshold
### return a matrix consisting of the number of DNA segments that display a ChIP-seq signal higher than the threshold (columns represent each TF and rows each threshold)
plotStatistics <- function(occupancy, TF, directory="", plotFilename="", imageType="pdf", threshold, backgroundSignal, profile, thresholdOnlyChIP=TRUE){
	
	figLabels = c("A", "B", "C", "D", "E", "F","G","H", "I","J","K","L","M","N");
	
	
	path="";
	if(!is.null(directory) & nchar(directory) > 0){
		path=paste(directory,"/", sep="");
	}
	
	filename=paste("OccupancyStatisticsBoxplot",plotFilename,".",sep="");
	
	

	locationsWithSignal=vector("list", length(threshold));
	correlationLocal=vector("list", length(threshold));
	mseLocal=vector("list", length(threshold));
	thetaLocal=vector("list", length(threshold));
		
	regions=matrix(0,nrow= length(threshold), ncol=length(TF))
	colnames(regions)=TF
	rownames(regions)=threshold
    
	minMSE=NULL;
	maxMSE=NULL;

	for(i in 1:length(threshold)){	
	       
		# extract the locations with signal higher than a threshold
		locationsWithSignal[[i]]=vector("list", length(TF));
		for(j in 1:length(TF)){
			buffer=c();
			for(k in 1:length(profile[[j]])){
				meanSignalLocal=mean(profile[[j]][[k]]);
				meanEstimateLocal=mean(occupancy$occupancyAbundanceChIP[[j]][[k]]);
				if((!is.na(meanSignalLocal) & meanSignalLocal > threshold[i]*backgroundSignal[[j]]) |
				   (!thresholdOnlyChIP & (!is.na(meanEstimateLocal) & meanEstimateLocal > threshold[i]*backgroundSignal[[j]]))){
					buffer=c(buffer,k); 
				}
			}
			locationsWithSignal[[i]][[j]]=buffer;
		}

		regions[i,]=unlist(lapply(locationsWithSignal[[i]],length));
		#print(unlist(lapply(locationsWithSignal[[i]],length)));
		correlationLocal[[i]]=vector("list", length(TF));
		names(correlationLocal[[i]])=TF;
		mseLocal[[i]]=vector("list", length(TF));
		names(mseLocal[[i]])=TF;
#		thetaLocal[[i]]=vector("list", length(TF));
#		names(thetaLocal[[i]])=TF;
		
		for(j in 1:length(TF)){
			bufferCorrelation=c();
			bufferMSE=c();
#			bufferTheta=c();
			for(k in locationsWithSignal[[i]][[j]]){
				bufferCorrelation=c(bufferCorrelation,occupancy$correlation[[j]][k]);
				bufferMSE=c(bufferMSE,occupancy$MSE[[j]][k]*1000);
#				bufferTheta=c(bufferTheta,occupancy$correlation[[j]][k]/(occupancy$MSE[[j]][k]*1000));
			}	
			correlationLocal[[i]][[j]]=bufferCorrelation;
			mseLocal[[i]][[j]]=bufferMSE;
#			thetaLocal[[i]][[j]]=bufferTheta;
            		if(is.null(minMSE)){
				minMSE=min(bufferMSE);
				maxMSE=max(bufferMSE);
			} else{
				if(minMSE > min(bufferMSE)){
					minMSE=min(bufferMSE);
				}
				if(maxMSE < max(bufferMSE)){
					maxMSE=max(bufferMSE);
				}
			}
		}
	}


	   
	#plot the boxplots with the statistics
	if(imageType=="pdf"){
		pdf(paste(path,filename,imageType,sep=""), width=(9), height=(3*length(threshold)),pointsize = 10);
	} else if(imageType=="eps"){
		postscript(paste(path,filename,imageType,sep=""), width=(9), height=(3*length(threshold)),pointsize = 10);
	}
	par(mfrow=c(length(threshold),2));
	
	par(cex=0.9);

	for(i in 1:length(threshold)){
		boxplot(correlationLocal[[i]], main="", ylab="", ylim=c(-1,1));
		title(main=paste("correlation (",threshold[i],")",sep=""));
		mtext(figLabels[(i-1)*2+1], line = 0.5, adj =0, cex=1.6);  
		boxplot(mseLocal[[i]], main="", ylab="",log="y", ylim=c(minMSE,maxMSE))
		title(main=paste("mean squared error (",threshold[i],")",sep=""));
		mtext(figLabels[(i-1)*2+2], line = 0.5, adj =0, cex=1.6);  

	}
	dev.off();

	filename=paste("OccupancyStatisticsPValue",plotFilename,".",sep="");
	#plot the p-value for the statistics
	if(length(threshold)==2){
		if(imageType=="pdf"){
			pdf(paste(path,filename,imageType,sep=""), width=(6), height=2.5,pointsize = 10);
		} else if(imageType=="eps"){
			postscript(paste(path,filename,imageType,sep=""), width=(6), height=2.5,pointsize = 10);
		}
		par(mfrow=c(1,1));
		par(mar=c(4, 10, 3, 1)+0.1);
		par(cex=0.9);

		colfunc=colorRampPalette(c("darkolivegreen4","white"));
		bufferColors=colfunc(10);
		ksColors=c(rep(bufferColors[1], times=35),rep(bufferColors[3], times=11),rep(bufferColors[10], times=4));
		ks.pvalue=matrix(0, nrow=2, ncol=length(TF));
		colnames(ks.pvalue)=TF;
		rownames(ks.pvalue)=c("correlation","mean squared error");
		for(j in 1:length(TF)){
			ks.pvalue[1,j]=ks.test(correlationLocal[[1]][[j]],correlationLocal[[2]][[j]])$p.value
			ks.pvalue[2,j]=ks.test(mseLocal[[1]][[j]],mseLocal[[2]][[j]])$p.value
		}
		
		ks.pvalue.binary=ks.pvalue;
		for(i in 1:nrow(ks.pvalue.binary)){
			for(j in 1:ncol(ks.pvalue.binary)){
				if(ks.pvalue.binary[i,j]==0.0){
					ks.pvalue.binary[i,j]=2e-16;
				} 
			}
		}

		print(log10(ks.pvalue.binary));		


		image(1:ncol(ks.pvalue),1:nrow(ks.pvalue),t(log10(ks.pvalue.binary)), axes = FALSE, main = "Kolmogorov-Smirnov test p-value", xlab="", ylab="",col=ksColors, zlim=c(-16,0));
		for(text.x.id in 1:nrow(ks.pvalue)){
			for(text.y.id in 1:ncol(ks.pvalue)){
				local.text=format(signif(t(ks.pvalue)[text.y.id,text.x.id],digits=2) , scientific = TRUE);
				text(text.y.id,text.x.id,local.text);
			}	
		}
	
		axis(BELOW<-1, at=1:ncol(ks.pvalue), labels=TF, cex.axis=1.0)
		axis(LEFT <-2, at=1:nrow(ks.pvalue), labels=rownames(ks.pvalue), las= HORIZONTAL<-1,cex.axis=1.0)
	

		dev.off();
	}

	return(regions);


signif(ks.test(count_genes_cleavage_sites,count_LTR_cleavage_sites)$p.value,digits=2)

}






### Plots occupancy profile.
### The grey shade represents the ChIP-seq signal, the red line the predicted profile from the model, the orange shade the inaccessible DNA and the vertical green lines the exponential of the PWM score
### occupancy: a list consisting of the computed profile at each loci
### PWMScore: a list consisting of the PWM scores at each loci
### lambda: the scaling factor of the PWM score
### maxPWMScore: the genome wide maximum PWM score
### DNAAccessibility=NULL: a list contsisting of the DNA accessibility data at each loci
### directory="": the folder where to save the plot
### plotFilename="": the plot filename (an extension and a prefix will be added to the plot filename)
### profile=NULL: a list consisting of the ChIP-seq signal at eac loci
### imageType="pdf" a string that specifies the image type. It can be eps or pdf.
### setSequence=NULL: the genomic ranges where to plot the profile. if NULL, nothing is plotted. 
### TF=NULL: the TF name for each the profile is plotted
### boundMolecules=NULL: the number of bound molecules 
### outputPWMScore=TRUE: logical value indicating whether the method should output the PWM score or not.
### outputOccupancyAbundance=TRUE: logical value indicating whether the method should output the  profile computed based on PWM score and number of bound molecules.
### geneRef=NULL. The gene reference list to be added to the graph. If NULL nothing is added. 
### stepSize=NULL. An integer indicating the step size of the landscape. 
plotOccupancyProfile <-function(occupancy, PWMScore, lambda, maxPWMScore, DNAAccessibility=NULL, directory="", plotFilename="", profile=NULL, imageType="pdf", setSequence=NULL,TF="", boundMolecules=NULL, outputPWMScore=TRUE, outputOccupancyAbundance=TRUE, geneRef=NULL,stepSize=NULL){
	
    
    cbbPalette = c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7");
	cbPalette = c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7");
    

	# colors
	colAccessibility=rgb(255,228,196,255,maxColorValue=255);
	colPWM=rgb(110,139,61,255,maxColorValue=255);
	colPWM=rgb(0,0,205,255,maxColorValue=255);
	colPWM=rgb(83,134,139,255,maxColorValue=255);
	colChIP=rgb(151,159,159,255,maxColorValue=255);
	colModel=rgb(139,62,47,255,maxColorValue=255);

    colAccessibility=cbPalette[5];
    colPWM=cbPalette[6];
    colChIP=cbPalette[1];
    colModel=cbPalette[7];
    colGene=cbPalette[4];
    colEnhancer=cbPalette[8];
   
    

	if(!is.null(setSequence)){
		
		#se the path to the destination directory
		path="";
		if(!is.null(directory) & nchar(directory) > 0){
			path=paste(directory,"/", sep="");
		}
	

	
		for(gr in 1:length(setSequence)){
			

			#get the id of the location in the list of loci
			chr=as.vector(seqnames(setSequence))[gr];
			range=ranges(setSequence);
			startPositon = as.vector(range@start)[gr];
			endPosition = as.vector(end(range))[gr];
			
			#the occupancy is computed just at the recorded sequences
			grID = which(names(PWMScore) == names(setSequence)[gr]);
			if(length(grID)!=1){
				grID=NULL;
			}
			
		
			if(is.null(grID)){
				print(paste("could not locate loci ",chr,":",startPositon,"..",endPosition, sep=""));
			} else{
			
				# the occupancy is computed genome wide and needs to be extracted at certain loci
	
				positions=startPositon:endPosition; 
					
				#generate the list of genese		
				geneList=NULL;
				enhancerList=NULL;
				if(!is.null(geneRef)) {
					if(length(which(names(geneRef)=="exon"))>0){
						idsExons = intersect(intersect(which(start(ranges(geneRef$exon))<endPosition), which(end(ranges(geneRef$exon))>=startPositon)), which(as.vector(seqnames(geneRef$exon))==chr));
						ids5UTR = intersect(intersect(which(start(ranges(geneRef[["5UTR"]]))<endPosition), which(end(ranges(geneRef[["5UTR"]]))>=startPositon)), which(as.vector(seqnames(geneRef[["5UTR"]]))==chr));
						ids3UTR = intersect(intersect(which(start(ranges(geneRef[["3UTR"]]))<endPosition), which(end(ranges(geneRef[["3UTR"]]))>=startPositon)), which(as.vector(seqnames(geneRef[["3UTR"]]))==chr));
						geneList = list("location"=c(geneRef$exon[idsExons],geneRef[["5UTR"]][ids5UTR],geneRef[["3UTR"]][ids3UTR]),"name"=c(names(geneRef$exon[idsExons]),names(geneRef[["5UTR"]][ids5UTR]),names(geneRef[["3UTR"]][ids3UTR]) ));
					}
					if(length(which(names(geneRef)=="enhancer"))>0){
						ids = intersect(intersect(which(start(ranges(geneRef$enhancer))<endPosition), which(end(ranges(geneRef$enhancer))>=startPositon)), which(as.vector(seqnames(geneRef$enhancer))==chr));	
						enhancerList = list("location"=geneRef$enhancer[ids],"name"=names(geneRef$enhancer[ids]));
					}
				}					 
									 
			

			
			
			
				filename=paste("OccupancyProfileAt",names(setSequence)[gr],"BoundMolecules",boundMolecules,plotFilename,".",sep="");
				if(imageType=="pdf"){
					pdf(paste(path,filename,imageType,sep=""), width=9, height=(2.25),pointsize = 10);
					
				} else if(imageType=="eps"){
					postscript(paste(path,filename,imageType,sep=""), width=9, height=(2.25),pointsize = 10);
	
				}
				par(mfrow=c(1,1));
				par(mar=c(4, 4, 3, 1)+0.1);
				par(cex=0.8);
				
				accesibilityNorm=DNAAccessibility[[grID]];
				
				if(outputOccupancyAbundance & !is.null(occupancy)){

					modelProfile=occupancy[[grID]];
					
					ylimMin = 0; 
					if(!is.null(geneList)){
						ylimMin= -0.5;
					}
					
					plotTitle="PWM and TF abundance";
					if(!is.null(TF) & !is.null(names(setSequence))){
						plotTitle=paste(TF," (",boundMolecules," molecules) @ ",names(setSequence)[gr], " locus", sep="");
					}
										
					localPositions=positions;
					localAccesibilityNorm=accesibilityNorm;
					localProfile=profile[[grID]];
					localModelProfile=modelProfile;
					if(!is.null(stepSize)){
						stepSize=round(stepSize);
						if(stepSize>1){
							localIndexes=seq(from=1,to=length(localPositions),by=stepSize);
							localPositions=rep(0,times=(length(localIndexes)-1));
							localAccesibilityNorm=rep(0,times=(length(localIndexes)-1));
							localProfile=rep(0,times=(length(localIndexes)-1));
							localModelProfile=rep(0,times=(length(localIndexes)-1));
							for(i in 1:(length(localIndexes)-1)){
								localPositions[i]=mean(positions[localIndexes[i]:(localIndexes[i+1]-1)]);
								localAccesibilityNorm[i]=mean(accesibilityNorm[localIndexes[i]:(localIndexes[i+1]-1)]);
								localProfile[i]=mean(profile[[grID]][localIndexes[i]:(localIndexes[i+1]-1)]);
								localModelProfile[i]=mean(modelProfile[localIndexes[i]:(localIndexes[i+1]-1)]);
							}
						}
					}
					
					localPositions=c(positions[1]-1,localPositions,positions[length(positions)]+1);
					localAccesibilityNorm=c(0,(1-localAccesibilityNorm),0);
					localProfile=c(0,localProfile, 0);
					localModelProfile=c(0,localModelProfile, 0);

					plot(localPositions, localModelProfile, type="n", yaxt="n", main=plotTitle, col=colModel, lty=1, lwd=2, pch=1, xlab="DNA position", ylab="occupancy", xlim=range(positions), ylim=c(ylimMin,1.5));

					
					if(!is.null(accesibilityNorm)){
						polygon(localPositions, localAccesibilityNorm, col=colAccessibility, border=NA) 
					}
					
					if(!is.null(profile)){
						polygon(localPositions,localProfile, col=colChIP, border=NA) 
					}		
				
					if(outputPWMScore){					
						PWMScoreNorm=PWMScore[[grID]];
						#PWMScoreNorm = (exp((1/lambda)*PWMScoreNorm))/(exp((1/lambda)*maxPWMScore));
						indexesAll=which(PWMScoreNorm>0.05);
						lines(positions[indexesAll], PWMScoreNorm[indexesAll], type="h", col=colPWM, lty=1, lwd=1.5, pch=1);
					}
				
					if(!is.null(profile[[grID]])){
						statTxt = paste("correlation = ",signif(cor(profile[[grID]],modelProfile),2), sep="");	
						statTxt = paste(statTxt, "; mean squared error = ",signif(1000*sum((profile[[grID]]-modelProfile)^2) / length(profile[[grID]]),3), sep="");
						#statTxt=bquote(rho[.(TF)] ~ " = " ~ .(signif(cor(profile[[grID]],modelProfile),2)) ~ "; "~ MSE[.(TF)] ~ " = " ~ .(signif(1000*sum((profile[[grID]]-modelProfile)^2) / length(profile[[grID]]),3)));
	
						mtext(statTxt, line = -1.5, adj =0.99, cex=1.0); 
						mtext(chr, line = -1.5, adj =0.01, cex=1.0);  
					}
					
					lines(localPositions, localModelProfile, pch=1, col=colModel, lty=1, lwd=2);
	
					if(!is.null(geneList)){
						
						for(geneName in unique(geneList$name)){
							lastExonXend = -1;
							lastExonYmed = -1;
							firstExonXStart = -1;
							
							for(k in which(geneList$name==geneName)){
								exonXStart = start(ranges(geneList$location[k]));
								exonXEnd = end(ranges(geneList$location[k]));
								exonYStart=-0.39;
								if(as.vector(strand(geneList$location[k])) == "+"){
									exonYStart = -0.25; 
								}
								exonYEnd=exonYStart+0.10;
								
								rect(exonXStart, exonYStart, exonXEnd, exonYEnd, col = colGene, border = colGene,lwd = 0);
								if(lastExonXend >= 0){
									lines(c(lastExonXend,exonXStart),c(lastExonYmed,((exonYStart + exonYEnd)/2)), col = colGene,lty=1, lwd=1);
								} else{
									firstExonXStart=exonXStart;
								}
								lastExonXend = exonXEnd;
								lastExonYmed = (exonYStart + exonYEnd)/2;
							}
							
							textPos=-0.465;
							if(exonYStart == -0.25){
								textPos=-0.085;		
							}
							
							text(((firstExonXStart+lastExonXend)/2), (textPos), geneName, cex = .6, col="black");
							
						}
						lines(c(min(positions),max(positions)),c(-0.26,-0.26), col = "black",lty=1, lwd=0.5);
						text(min(positions), -0.10, "+", cex = .6, col="black");
						text(min(positions), -0.42, "-", cex = .6, col="black");
						
						
					}
					
					if(!is.null(enhancerList)){
						
						for(enhancerName in unique(enhancerList$name)){
							lastEnhancerXend = -1;
							lastEnhancerYmed = -1;
							firstEnhancerXStart = -1;
							
							for(k in which(enhancerList$name==enhancerName)){
								enhancerXStart = start(ranges(enhancerList$location[k]));
								enhancerXEnd = end(ranges(enhancerList$location[k]));
								enhancerYStart=-0.39;
								enhancerYEnd=enhancerYStart+0.10;
								
								rect(enhancerXStart, enhancerYStart, enhancerXEnd, enhancerYEnd, col = colEnhancer, border = colEnhancer,lwd = 0);
								if(lastEnhancerXend >= 0){
									lines(c(lastEnhancerXend,enhancerXStart),c(lastEnhancerYmed,((enhancerYStart + enhancerYEnd)/2)), col = colEnhancer,lty=1, lwd=1);
								} else{
									firstEnhancerXStart=enhancerXStart;
								}
								lastEnhancerXend = enhancerXEnd;
								lastEnhancerYmed = (enhancerYStart + enhancerYEnd)/2;
							}
							
							textPos=-0.465;
							if(enhancerYStart == -0.25){
								textPos=-0.085;		
							}
							
							text(((firstEnhancerXStart+lastEnhancerXend)/2), (textPos), enhancerName, cex = .6, col="black");
							
						}
						if(is.null(geneList)){
							lines(c(min(positions),max(positions)),c(-0.26,-0.26), col = "black",lty=1, lwd=0.5);
							text(min(positions), -0.10, "+", cex = .6, col="black");
							text(min(positions), -0.42, "-", cex = .6, col="black");
						}
						
						
					}
					
	
				}
				
				
			}
						
			dev.off();
		}
		
	}		
	
	
}
